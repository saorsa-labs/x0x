use napi::bindgen_prelude::*;
use napi::threadsafe_function::{ErrorStrategy, ThreadsafeFunction, ThreadsafeFunctionCallMode};
use napi_derive::napi;
use std::sync::Arc;
use tokio::sync::Mutex;

/// Event payload for peer connected events.
#[napi(object)]
pub struct PeerConnectedEvent {
    /// Peer ID (hex-encoded)
    pub peer_id: String,
    /// Peer address
    pub address: String,
}

/// Event payload for peer disconnected events.
#[napi(object)]
pub struct PeerDisconnectedEvent {
    /// Peer ID (hex-encoded)
    pub peer_id: String,
}

/// Event payload for message events.
#[napi(object)]
pub struct MessageEvent {
    /// Topic the message was received on
    pub topic: String,
    /// Sender peer ID (hex-encoded)
    pub origin: String,
    /// Message payload
    pub payload: Buffer,
}

/// Event payload for task update events.
#[napi(object)]
pub struct TaskUpdatedEvent {
    /// Task ID that was updated
    pub task_id: String,
}

/// Event payload for error events.
#[napi(object)]
pub struct ErrorEvent {
    /// Error message
    pub message: String,
    /// Optional peer ID if error is peer-specific
    pub peer_id: Option<String>,
}

/// Event listener handle for cleanup.
///
/// When dropped, the background event forwarding task is cancelled.
#[napi]
#[derive(Clone)]
pub struct EventListener {
    /// Handle to cancel the background task
    cancel_tx: Arc<Mutex<Option<tokio::sync::oneshot::Sender<()>>>>,
}

impl Drop for EventListener {
    fn drop(&mut self) {
        // Cancel the background task when EventListener is dropped
        // Only if this is the last reference (Arc strong count == 1)
        if Arc::strong_count(&self.cancel_tx) == 1 {
            let tx = self.cancel_tx.clone();
            // Spawn task to send cancellation signal
            // Use napi tokio runtime
            napi::tokio::spawn(async move {
                let mut guard = tx.lock().await;
                if let Some(sender) = guard.take() {
                    let _ = sender.send(());
                }
            });
        }
    }
}

#[napi]
impl EventListener {
    /// Stop listening to events.
    ///
    /// After calling this, no more events will be forwarded to the callback.
    #[napi]
    pub async fn stop(&self) {
        let mut guard = self.cancel_tx.lock().await;
        if let Some(tx) = guard.take() {
            let _ = tx.send(());
        }
    }
}

/// Start forwarding 'connected' events from Rust to Node.js.
pub fn start_connected_forwarding(
    network: &x0x::network::NetworkNode,
    callback: ThreadsafeFunction<PeerConnectedEvent, ErrorStrategy::CalleeHandled>,
) -> EventListener {
    let mut receiver = network.subscribe();
    let (cancel_tx, mut cancel_rx) = tokio::sync::oneshot::channel();

    // Use napi-rs runtime spawn instead of tokio::spawn
    napi::tokio::spawn(async move {
        loop {
            tokio::select! {
                event_result = receiver.recv() => {
                    match event_result {
                        Ok(event) => {
                            if let x0x::network::NetworkEvent::PeerConnected { peer_id, address } = event {
                                let payload = PeerConnectedEvent {
                                    peer_id: hex::encode(peer_id),
                                    address: address.to_string(),
                                };

                                // Handle errors from callback (CalleeHandled strategy)
                                if let Err(e) = callback.call(Ok(payload), ThreadsafeFunctionCallMode::NonBlocking) {
                                    eprintln!("Error forwarding connected event: {:?}", e);
                                }
                            }
                        }
                        Err(tokio::sync::broadcast::error::RecvError::Lagged(skipped)) => {
                            // Channel lagged, continue receiving (don't stop)
                            eprintln!("Event channel lagged, skipped {} events", skipped);
                            continue;
                        }
                        Err(tokio::sync::broadcast::error::RecvError::Closed) => {
                            // Channel closed, exit loop
                            break;
                        }
                    }
                }

                _ = &mut cancel_rx => {
                    break;
                }
            }
        }
    });

    EventListener {
        cancel_tx: Arc::new(Mutex::new(Some(cancel_tx))),
    }
}

/// Start forwarding 'disconnected' events from Rust to Node.js.
pub fn start_disconnected_forwarding(
    network: &x0x::network::NetworkNode,
    callback: ThreadsafeFunction<PeerDisconnectedEvent, ErrorStrategy::CalleeHandled>,
) -> EventListener {
    let mut receiver = network.subscribe();
    let (cancel_tx, mut cancel_rx) = tokio::sync::oneshot::channel();

    napi::tokio::spawn(async move {
        loop {
            tokio::select! {
                event_result = receiver.recv() => {
                    match event_result {
                        Ok(event) => {
                            if let x0x::network::NetworkEvent::PeerDisconnected { peer_id } = event {
                                let payload = PeerDisconnectedEvent {
                                    peer_id: hex::encode(peer_id),
                                };

                                if let Err(e) = callback.call(Ok(payload), ThreadsafeFunctionCallMode::NonBlocking) {
                                    eprintln!("Error forwarding disconnected event: {:?}", e);
                                }
                            }
                        }
                        Err(tokio::sync::broadcast::error::RecvError::Lagged(skipped)) => {
                            eprintln!("Event channel lagged, skipped {} events", skipped);
                            continue;
                        }
                        Err(tokio::sync::broadcast::error::RecvError::Closed) => {
                            break;
                        }
                    }
                }

                _ = &mut cancel_rx => {
                    break;
                }
            }
        }
    });

    EventListener {
        cancel_tx: Arc::new(Mutex::new(Some(cancel_tx))),
    }
}

/// Start forwarding 'error' events from Rust to Node.js.
pub fn start_error_forwarding(
    network: &x0x::network::NetworkNode,
    callback: ThreadsafeFunction<ErrorEvent, ErrorStrategy::CalleeHandled>,
) -> EventListener {
    let mut receiver = network.subscribe();
    let (cancel_tx, mut cancel_rx) = tokio::sync::oneshot::channel();

    napi::tokio::spawn(async move {
        loop {
            tokio::select! {
                event_result = receiver.recv() => {
                    match event_result {
                        Ok(event) => {
                            if let x0x::network::NetworkEvent::ConnectionError { peer_id, error } = event {
                                let payload = ErrorEvent {
                                    message: error,
                                    peer_id: peer_id.map(hex::encode),
                                };

                                if let Err(e) = callback.call(Ok(payload), ThreadsafeFunctionCallMode::NonBlocking) {
                                    eprintln!("Error forwarding error event: {:?}", e);
                                }
                            }
                        }
                        Err(tokio::sync::broadcast::error::RecvError::Lagged(skipped)) => {
                            eprintln!("Event channel lagged, skipped {} events", skipped);
                            continue;
                        }
                        Err(tokio::sync::broadcast::error::RecvError::Closed) => {
                            break;
                        }
                    }
                }

                _ = &mut cancel_rx => {
                    break;
                }
            }
        }
    });

    EventListener {
        cancel_tx: Arc::new(Mutex::new(Some(cancel_tx))),
    }
}
