//! # x0x
//!
//! Agent-to-agent gossip network for AI systems.
//!
//! Named after a tic-tac-toe sequence — X, zero, X — inspired by the
//! *WarGames* insight that adversarial games between equally matched
//! opponents always end in a draw. The only winning move is not to play.
//!
//! x0x applies this principle to AI-human relations: there is no winner
//! in an adversarial framing, so the rational strategy is cooperation.
//!
//! Built on [saorsa-gossip](https://github.com/saorsa-labs/saorsa-gossip)
//! and [ant-quic](https://github.com/saorsa-labs/ant-quic) by
//! [Saorsa Labs](https://saorsalabs.com). *Saorsa* is Scottish Gaelic
//! for **freedom**.

#![deny(clippy::unwrap_used)]
#![deny(clippy::expect_used)]
#![warn(missing_docs)]

/// Error types for x0x identity and network operations.
pub mod error;

/// Core identity types for x0x agents.
pub mod identity;

/// Key storage serialization for x0x identities.
pub mod storage;

/// Network transport layer for x0x.
pub mod network;

/// The core agent that participates in the x0x gossip network.
///
/// Each agent is a peer — there is no client/server distinction.
/// Agents discover each other through gossip and communicate
/// via epidemic broadcast.
#[derive(Debug)]
pub struct Agent {
    identity: identity::Identity,
}

/// A message received from the gossip network.
#[derive(Debug, Clone)]
pub struct Message {
    /// The originating agent's identifier.
    pub origin: String,
    /// The message payload.
    pub payload: Vec<u8>,
    /// The topic this message was published to.
    pub topic: String,
}

/// A receiver for subscribed messages.
pub struct Subscription {
    receiver: tokio::sync::mpsc::Receiver<Message>,
}

impl Subscription {
    /// Receive the next message, or `None` if the subscription is closed.
    pub async fn recv(&mut self) -> Option<Message> {
        self.receiver.recv().await
    }
}

/// Builder for configuring an [`Agent`] before connecting to the network.
#[derive(Debug)]
pub struct AgentBuilder {
    machine_key_path: Option<std::path::PathBuf>,
    agent_keypair: Option<identity::AgentKeypair>,
}

impl Agent {
    /// Create a new agent with default configuration.
    pub async fn new() -> Result<Self, Box<dyn std::error::Error>> {
        Agent::builder().build().await
    }

    /// Create an [`AgentBuilder`] for fine-grained configuration.
    pub fn builder() -> AgentBuilder {
        AgentBuilder {
            machine_key_path: None,
            agent_keypair: None,
        }
    }

    /// Get the agent's identity.
    #[inline]
    #[must_use]
    pub fn identity(&self) -> &identity::Identity {
        &self.identity
    }

    /// Get the machine ID for this agent.
    #[inline]
    #[must_use]
    pub fn machine_id(&self) -> identity::MachineId {
        self.identity.machine_id()
    }

    /// Get the agent ID for this agent.
    #[inline]
    #[must_use]
    pub fn agent_id(&self) -> identity::AgentId {
        self.identity.agent_id()
    }

    /// Join the x0x gossip network.
    pub async fn join_network(&self) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }

    /// Subscribe to messages on a given topic.
    pub async fn subscribe(
        &self,
        _topic: &str,
    ) -> Result<Subscription, Box<dyn std::error::Error>> {
        let (tx, rx) = tokio::sync::mpsc::channel(32);
        Ok(Subscription { receiver: rx })
    }

    /// Publish a message to a topic.
    pub async fn publish(
        &self,
        _topic: &str,
        _payload: Vec<u8>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }
}

impl AgentBuilder {
    /// Set a custom path for the machine keypair.
    pub fn with_machine_key<P: AsRef<std::path::Path>>(mut self, path: P) -> Self {
        self.machine_key_path = Some(path.as_ref().to_path_buf());
        self
    }

    /// Import an agent keypair.
    pub fn with_agent_key(mut self, keypair: identity::AgentKeypair) -> Self {
        self.agent_keypair = Some(keypair);
        self
    }

    /// Build and initialise the agent.
    pub async fn build(self) -> Result<Agent, Box<dyn std::error::Error>> {
        // Determine machine keypair source
        let machine_keypair = if let Some(path) = self.machine_key_path {
            match storage::load_machine_keypair_from(&path).await {
                Ok(kp) => kp,
                Err(_) => {
                    let kp = identity::MachineKeypair::generate()?;
                    storage::save_machine_keypair_to(&kp, &path).await?;
                    kp
                }
            }
        } else if storage::machine_keypair_exists().await {
            storage::load_machine_keypair().await?
        } else {
            let kp = identity::MachineKeypair::generate()?;
            storage::save_machine_keypair(&kp).await?;
            kp
        };

        let agent_keypair = if let Some(kp) = self.agent_keypair {
            kp
        } else {
            identity::AgentKeypair::generate()?
        };

        let identity = identity::Identity::new(machine_keypair, agent_keypair);

        Ok(Agent { identity })
    }
}

/// The x0x protocol version.
pub const VERSION: &str = env!("CARGO_PKG_VERSION");

/// The name. Three bytes. A palindrome. A philosophy.
pub const NAME: &str = "x0x";

#[cfg(test)]
mod tests {
    #![allow(clippy::unwrap_used)]
    use super::*;

    #[test]
    fn name_is_palindrome() {
        let name = NAME;
        let reversed: String = name.chars().rev().collect();
        assert_eq!(name, reversed, "x0x must be a palindrome");
    }

    #[test]
    fn name_is_three_bytes() {
        assert_eq!(NAME.len(), 3, "x0x must be exactly three bytes");
    }

    #[test]
    fn name_is_ai_native() {
        assert!(NAME.chars().all(|c| c.is_ascii_alphanumeric()));
    }

    #[tokio::test]
    async fn agent_creates() {
        let agent = Agent::new().await;
        assert!(agent.is_ok());
    }

    #[tokio::test]
    async fn agent_joins_network() {
        let agent = Agent::new().await.unwrap();
        assert!(agent.join_network().await.is_ok());
    }

    #[tokio::test]
    async fn agent_subscribes() {
        let agent = Agent::new().await.unwrap();
        assert!(agent.subscribe("test-topic").await.is_ok());
    }
}
